<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `DelaunayTriangulation` struct in crate `spade`."><meta name="keywords" content="rust, rustlang, rust-lang, DelaunayTriangulation"><title>spade::delaunay::DelaunayTriangulation - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Struct DelaunayTriangulation</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.with_tree_locate">with_tree_locate</a><a href="#method.with_walk_locate">with_walk_locate</a><a href="#method.new">new</a><a href="#method.vertex">vertex</a><a href="#method.vertex_mut">vertex_mut</a><a href="#method.face">face</a><a href="#method.edge">edge</a><a href="#method.num_vertices">num_vertices</a><a href="#method.num_faces">num_faces</a><a href="#method.num_triangles">num_triangles</a><a href="#method.num_edges">num_edges</a><a href="#method.triangles">triangles</a><a href="#method.edges">edges</a><a href="#method.vertices">vertices</a><a href="#method.infinite_face">infinite_face</a><a href="#method.is_degenerate">is_degenerate</a><a href="#method.get_edge_from_neighbors">get_edge_from_neighbors</a><a href="#method.nearest_neighbor">nearest_neighbor</a><a href="#method.locate">locate</a><a href="#method.locate_vertex">locate_vertex</a><a href="#method.locate_with_hint">locate_with_hint</a><a href="#method.insert">insert</a><a href="#method.insert_with_hint">insert_with_hint</a><a href="#method.locate_and_remove">locate_and_remove</a><a href="#method.remove">remove</a><a href="#method.lookup">lookup</a><a href="#method.lookup_and_remove">lookup_and_remove</a><a href="#method.barycentric_interpolation">barycentric_interpolation</a><a href="#method.nn_interpolation">nn_interpolation</a><a href="#method.estimate_normal">estimate_normal</a><a href="#method.estimate_gradient">estimate_gradient</a><a href="#method.nn_interpolation_c1_sibson">nn_interpolation_c1_sibson</a><a href="#method.nn_interpolation_c1_farin">nn_interpolation_c1_farin</a><a href="#method.estimate_normals">estimate_normals</a><a href="#method.estimate_gradients">estimate_gradients</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div></div><p class='location'><a href='../index.html'>spade</a>::<wbr><a href='index.html'>delaunay</a></p><script>window.sidebarCurrent = {name: 'DelaunayTriangulation', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>spade</a>::<wbr><a href='index.html'>delaunay</a>::<wbr><a class="struct" href=''>DelaunayTriangulation</a></span><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#136-146' title='goto source code'>[src]</a></span></h1><div class="docblock type-decl"><pre class='rust struct'>pub struct DelaunayTriangulation&lt;V, K, L&nbsp;=&nbsp;<a class="type" href="../../spade/delaunay/type.DelaunayTreeLocate.html" title="type spade::delaunay::DelaunayTreeLocate">DelaunayTreeLocate</a>&lt;&lt;V as <a class="trait" href="../../spade/trait.HasPosition.html" title="trait spade::HasPosition">HasPosition</a>&gt;::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../spade/trait.HasPosition2D.html" title="trait spade::HasPosition2D">HasPosition2D</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../../spade/kernels/trait.DelaunayKernel.html" title="trait spade::kernels::DelaunayKernel">DelaunayKernel</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>: <a class="trait" href="../../spade/trait.TwoDimensional.html" title="trait spade::TwoDimensional">TwoDimensional</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;L: <a class="trait" href="../../spade/delaunay/trait.DelaunayLocateStructure.html" title="trait spade::delaunay::DelaunayLocateStructure">DelaunayLocateStructure</a>&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>&gt;,&nbsp;</span> { /* fields omitted */ }</pre></div><div class='docblock'><p>A two dimensional Delaunay triangulation.</p>
<p>A Delaunay triangulation is a special triangulation of a set of points that fulfills some
suitable properties for geometric operations like interpolation.
There is also an <a href="https://stoeoef.gitbooks.io/spade-user-manual/content/delaunay-triangulation.html">own chapter</a> in the user guide covering spade's triangulation.</p>
<p>Objects that are inserted into the triangulation have to implement the <code>HasPosition2D</code> trait.
The trait is implemented for all types that implement <code>TwoDimensional</code>, like <code>Point2</code> from
the <code>cgmath</code> and <code>nalgebra</code> package or <code>[S; 2]</code> for <code>S: SpadeNum</code>.</p>
<p>A straightforward Delaunay triangulation implementation will suffer from precision problems:
various geometric queries can fail if imprecise calculations (like native <code>f32</code> / <code>f64</code> operations)
are used. Those failures can yield to incorrect results or panics at runtime.
To prevent those crashes, Spade offers a few &quot;calculation kernels&quot; that may fit the
individual needs of an application. See <code>spade::kernels</code> for more information.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nalgebra</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">spade</span>;

<span class="kw">use</span> <span class="ident">nalgebra</span>::<span class="ident">Point2</span>;
<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">delaunay</span>::<span class="ident">FloatDelaunayTriangulation</span>;

  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">delaunay</span> <span class="op">=</span> <span class="ident">FloatDelaunayTriangulation</span>::<span class="ident">with_walk_locate</span>();
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.0</span>, <span class="number">1.0</span>));
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.0</span>, <span class="op">-</span><span class="number">1.0</span>));
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">1.0</span>, <span class="number">0.0</span>));
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">Point2</span>::<span class="ident">new</span>(<span class="op">-</span><span class="number">1.0</span>, <span class="number">0.0</span>));
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.0</span>, <span class="number">0.0</span>));
  <span class="kw">for</span> <span class="ident">face</span> <span class="kw">in</span> <span class="ident">delaunay</span>.<span class="ident">triangles</span>() {
    <span class="kw">let</span> <span class="ident">triangle</span> <span class="op">=</span> <span class="ident">face</span>.<span class="ident">as_triangle</span>();
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Found triangle: {:?} -&gt; {:?} -&gt; {:?}&quot;</span>, <span class="kw-2">*</span><span class="ident">triangle</span>[<span class="number">0</span>], <span class="kw-2">*</span><span class="ident">triangle</span>[<span class="number">1</span>], <span class="kw-2">*</span><span class="ident">triangle</span>[<span class="number">2</span>]);
  }
  <span class="kw">for</span> <span class="ident">edge</span> <span class="kw">in</span> <span class="ident">delaunay</span>.<span class="ident">edges</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Found an edge: {:?} -&gt; {:?}&quot;</span>, <span class="kw-2">*</span><span class="ident">edge</span>.<span class="ident">from</span>(), <span class="kw-2">*</span><span class="ident">edge</span>.<span class="ident">to</span>());
  }</pre>
<h1 id="iterating" class="section-header"><a href="#iterating">Iterating</a></h1>
<p>A triangulation consists of three elements - vertices, edges and triangles - that can be iterated over.
Use <code>vertices()</code> <code>edges()</code> and <code>triangles()</code> to call appropriate, non-mutating iterators.</p>
<h1 id="infinite-face-and-convex-hull" class="section-header"><a href="#infinite-face-and-convex-hull">Infinite face and convex hull</a></h1>
<p>Every triangulation is surrounded by the <em>infinite face</em>. This face can be retrieved by calling
<code>infinite_face()</code>. Iterating the adjacent edges of the infinite face will yield the triangulation's
convex hull. See <code>FaceHandle::adjacent_edges()</code>.</p>
<h1 id="mutating" class="section-header"><a href="#mutating">Mutating</a></h1>
<p>Vertices can be added and removed. Mutation of vertex data is possible with <code>lookup_mut(..)</code>,
although this mutation must not alter the vertex position.</p>
<h1 id="interpolation" class="section-header"><a href="#interpolation">Interpolation</a></h1>
<p>Vertices can store various user data, the points could for example represent meteorological samples
measuring temperature or air moisture. These values can be interpolated smoothly within the
triangulation's convex hull using a variety of interpolation methods. There are currently four supported
interpolation methods:</p>
<ul>
<li><code>barycentric_interpolation(..)</code></li>
<li><code>nn_interpolation(..)</code></li>
<li><code>nn_interpolation_c1_sibson(..)</code></li>
<li><code>nn_interpolation_c1_farin(..)</code></li>
</ul>
<h1 id="type-parameters" class="section-header"><a href="#type-parameters">Type parameters</a></h1>
<p><code>DelaunayTriangulation</code> has three type parameters: <code>V</code>, <code>K</code> and <code>L</code>.
<code>V: HasPosition2D</code> defines the triangulation's vertex type.
<code>K: DelaunayKernel</code> defines the triangulations calculation kernel.
For more information, see <code>spade::kernels</code>.
<code>L</code> Defines the locate structure.
For more information, see <code>DelaunayLocateStructure</code>.</p>
<h1 id="performance" class="section-header"><a href="#performance">Performance</a></h1>
<p>Performance of insertion, interpolation and other queries heavily relies on</p>
<ul>
<li>the locate structure being used</li>
<li>the closeness of subsequent queries</li>
<li>the kernel being used
Depending on the use case, it can vary between O(1) to O(sqrt(n)) on average.
The guide has an <a href="https://stoeoef.gitbooks.io/spade-user-manual/content/triangulation-performance.html">own chapter</a>
about performance.</li>
</ul>
<h2 id="auto-hinting" class="section-header"><a href="#auto-hinting">Auto Hinting</a></h2>
<p>Since version 1.1, spade uses the result of the last query as hint for the next query when
using <code>DelaunayWalkLocate</code> as locate strategy. As a consequence, subsequent
queries - like insertion, interpolation or nearest neighbor queries - will
run in O(1) if the query locations are close to each other.</p>
</div>
                    <h2 id='methods' class='small-section-header'>
                      Methods<a href='#methods' class='anchor'></a>
                    </h2>
                <h3 id='impl' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;V, K&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../spade/trait.HasPosition2D.html" title="trait spade::HasPosition2D">HasPosition2D</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../../spade/kernels/trait.DelaunayKernel.html" title="trait spade::kernels::DelaunayKernel">DelaunayKernel</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>: <a class="trait" href="../../spade/trait.TwoDimensional.html" title="trait spade::TwoDimensional">TwoDimensional</a>,&nbsp;</span></code><a href='#impl' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#206-226' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.with_tree_locate' class="method"><span id='with_tree_locate.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.with_tree_locate' class='fnname'>with_tree_locate</a>() -&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#214-216' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Shorthand constructor for a Delaunay triangulation that is backed up by an r-tree for
log(n) insertion and locate time on average.</p>
</div><h4 id='method.with_walk_locate' class="method"><span id='with_walk_locate.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.with_walk_locate' class='fnname'>with_walk_locate</a>() -&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, <a class="struct" href="../../spade/delaunay/struct.DelaunayWalkLocate.html" title="struct spade::delaunay::DelaunayWalkLocate">DelaunayWalkLocate</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#222-225' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Shorthand constructor for a Delaunay triangulation that uses the
<code>DelaunayWalkLocate</code> strategy for insertion and point location
queries. This yields O(sqrt(n)) insertion time on average for
randomly generated vertices.</p>
</div></div><h3 id='impl-1' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;V, K, L&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, L&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../spade/trait.HasPosition2D.html" title="trait spade::HasPosition2D">HasPosition2D</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../../spade/kernels/trait.DelaunayKernel.html" title="trait spade::kernels::DelaunayKernel">DelaunayKernel</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>: <a class="trait" href="../../spade/trait.TwoDimensional.html" title="trait spade::TwoDimensional">TwoDimensional</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;L: <a class="trait" href="../../spade/delaunay/trait.DelaunayLocateStructure.html" title="trait spade::delaunay::DelaunayLocateStructure">DelaunayLocateStructure</a>&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>&gt;,&nbsp;</span></code><a href='#impl-1' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#228-464' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.new' class="method"><span id='new.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, L&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#256-263' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a new Delaunay triangulation.</p>
<p>Using this method directly can be a bit cumbersome due to type annotations, consider using
The short hand definitions <code>FloatDelaunayTriangulation</code> or <code>IntDelaunayTriangulation</code> in
combination with the methods <code>with_walk_locate</code> and <code>with_tree_locate</code>.</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">delaunay</span>::{<span class="ident">DelaunayTriangulation</span>, <span class="ident">DelaunayWalkLocate</span>};
<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">kernels</span>::<span class="ident">FloatKernel</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">triangulation</span> <span class="op">=</span> <span class="ident">DelaunayTriangulation</span>::<span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">FloatKernel</span>, <span class="ident">DelaunayWalkLocate</span><span class="op">&gt;</span>::<span class="ident">new</span>();</pre>
<p>Usually, the omitted types (the triangulation's vertex type) can be inferred from a call
to <code>insert</code>.</p>
</div><h4 id='method.vertex' class="method"><span id='vertex.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.vertex' class='fnname'>vertex</a>(&amp;self, handle: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a>) -&gt; <a class="struct" href="../../spade/delaunay/struct.VertexHandle.html" title="struct spade::delaunay::VertexHandle">VertexHandle</a>&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#269-271' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a dynamic vertex handle from a fixed vertex handle.</p>
<p>May panic if the handle was invalidated by a previous vertex
removal.</p>
</div><h4 id='method.vertex_mut' class="method"><span id='vertex_mut.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.vertex_mut' class='fnname'>vertex_mut</a>(&amp;mut self, handle: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>V</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#275-277' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a mutable reference to the vertex data referenced by a
<code>FixedVertexHandle</code>.</p>
</div><h4 id='method.face' class="method"><span id='face.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.face' class='fnname'>face</a>(&amp;self, handle: <a class="type" href="../../spade/delaunay/type.FixedFaceHandle.html" title="type spade::delaunay::FixedFaceHandle">FixedFaceHandle</a>) -&gt; <a class="struct" href="../../spade/delaunay/struct.FaceHandle.html" title="struct spade::delaunay::FaceHandle">FaceHandle</a>&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#283-285' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a dynamic face handle from a fixed face handle.</p>
<p>May panic if the faces was invalidated by a previous vertex
removal.</p>
</div><h4 id='method.edge' class="method"><span id='edge.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.edge' class='fnname'>edge</a>(&amp;self, handle: <a class="type" href="../../spade/delaunay/type.FixedEdgeHandle.html" title="type spade::delaunay::FixedEdgeHandle">FixedEdgeHandle</a>) -&gt; <a class="struct" href="../../spade/delaunay/struct.EdgeHandle.html" title="struct spade::delaunay::EdgeHandle">EdgeHandle</a>&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#291-293' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Creates a dynamic edge handle from a fixed edge handle.</p>
<p>May panic if the handle was invalidated by a previous vertex
removal.</p>
</div><h4 id='method.num_vertices' class="method"><span id='num_vertices.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.num_vertices' class='fnname'>num_vertices</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#296-298' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the number of vertices in this triangulation.</p>
</div><h4 id='method.num_faces' class="method"><span id='num_faces.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.num_faces' class='fnname'>num_faces</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#303-305' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the number of faces in this triangulation.</p>
<p>This count does include the infinite face.</p>
</div><h4 id='method.num_triangles' class="method"><span id='num_triangles.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.num_triangles' class='fnname'>num_triangles</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#311-313' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the number of triangles in this triangulation.</p>
<p>As there is always exactly one face not being a triangle,
this is equivalent to <code>self.num_faces() - 1</code>.</p>
</div><h4 id='method.num_edges' class="method"><span id='num_edges.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.num_edges' class='fnname'>num_edges</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#316-318' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the number of edges in this triangulation.</p>
</div><h4 id='method.triangles' class="method"><span id='triangles.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.triangles' class='fnname'>triangles</a>(&amp;self) -&gt; FacesIterator&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#321-326' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns an iterator over all triangles.</p>
</div><h4 id='method.edges' class="method"><span id='edges.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.edges' class='fnname'>edges</a>(&amp;self) -&gt; EdgesIterator&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#329-331' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns an iterator over all undirected edges.</p>
</div><h4 id='method.vertices' class="method"><span id='vertices.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.vertices' class='fnname'>vertices</a>(&amp;self) -&gt; VerticesIterator&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#334-336' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns an iterator over all vertices.</p>
</div><h4 id='method.infinite_face' class="method"><span id='infinite_face.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.infinite_face' class='fnname'>infinite_face</a>(&amp;self) -&gt; <a class="struct" href="../../spade/delaunay/struct.FaceHandle.html" title="struct spade::delaunay::FaceHandle">FaceHandle</a>&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#339-341' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a handle to the infinite face.</p>
</div><h4 id='method.is_degenerate' class="method"><span id='is_degenerate.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.is_degenerate' class='fnname'>is_degenerate</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#347-349' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns <code>true</code> if the triangulation is degenerate</p>
<p>A triangulation is degenerate if all vertices of the
triangulation lie on one line.</p>
</div><h4 id='method.get_edge_from_neighbors' class="method"><span id='get_edge_from_neighbors.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.get_edge_from_neighbors' class='fnname'>get_edge_from_neighbors</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;from: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;to: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../spade/delaunay/struct.EdgeHandle.html" title="struct spade::delaunay::EdgeHandle">EdgeHandle</a>&lt;V&gt;&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#356-358' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns an edge between two vertices.</p>
<p>If the edge does not exist, <code>None</code> is returned.
This operation runs in <code>O(n)</code> time, where <code>n</code> is
the degree of <code>from</code>.</p>
</div><h4 id='method.nearest_neighbor' class="method"><span id='nearest_neighbor.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.nearest_neighbor' class='fnname'>nearest_neighbor</a>(&amp;self, point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../spade/delaunay/struct.VertexHandle.html" title="struct spade::delaunay::VertexHandle">VertexHandle</a>&lt;V&gt;&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#363-384' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Locates the nearest neighbor for a given point.</p>
<p>Returns <code>None</code> if the triangulation is empty.</p>
</div><h4 id='method.locate' class="method"><span id='locate.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.locate' class='fnname'>locate</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a><br>) -&gt; <a class="enum" href="../../spade/delaunay/enum.PositionInTriangulation.html" title="enum spade::delaunay::PositionInTriangulation">PositionInTriangulation</a>&lt;<a class="struct" href="../../spade/delaunay/struct.VertexHandle.html" title="struct spade::delaunay::VertexHandle">VertexHandle</a>&lt;V&gt;, <a class="struct" href="../../spade/delaunay/struct.FaceHandle.html" title="struct spade::delaunay::FaceHandle">FaceHandle</a>&lt;V&gt;, <a class="struct" href="../../spade/delaunay/struct.EdgeHandle.html" title="struct spade::delaunay::EdgeHandle">EdgeHandle</a>&lt;V&gt;&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#387-390' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns information about the location of a point in a triangulation.</p>
</div><h4 id='method.locate_vertex' class="method"><span id='locate_vertex.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.locate_vertex' class='fnname'>locate_vertex</a>(&amp;self, point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../spade/delaunay/struct.VertexHandle.html" title="struct spade::delaunay::VertexHandle">VertexHandle</a>&lt;V&gt;&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#395-402' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Locates a vertex at a given position.</p>
<p>Returns <code>None</code> if the point could not be found.</p>
</div><h4 id='method.locate_with_hint' class="method"><span id='locate_with_hint.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.locate_with_hint' class='fnname'>locate_with_hint</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;hint: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a><br>) -&gt; <a class="enum" href="../../spade/delaunay/enum.PositionInTriangulation.html" title="enum spade::delaunay::PositionInTriangulation">PositionInTriangulation</a>&lt;<a class="struct" href="../../spade/delaunay/struct.VertexHandle.html" title="struct spade::delaunay::VertexHandle">VertexHandle</a>&lt;V&gt;, <a class="struct" href="../../spade/delaunay/struct.FaceHandle.html" title="struct spade::delaunay::FaceHandle">FaceHandle</a>&lt;V&gt;, <a class="struct" href="../../spade/delaunay/struct.EdgeHandle.html" title="struct spade::delaunay::EdgeHandle">EdgeHandle</a>&lt;V&gt;&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#408-410' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns information about the location of a point in a triangulation.</p>
<p>Additionally, a hint can be given to speed up computation. The hint should be a vertex close
to the position that is being looked up.</p>
</div><h4 id='method.insert' class="method"><span id='insert.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.insert' class='fnname'>insert</a>(&amp;mut self, t: V) -&gt; <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#421-423' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Inserts a new vertex into the triangulation.</p>
<p>This operation runs in <code>O(log(n))</code> on average when using a tree lookup to back up the
triangulation, or in <code>O(sqrt(n))</code> when using a walk lookup. <code>n</code> denotes the number of vertices,
the given running times assume that input data is given uniformly randomly distributed.
If the point has already been contained in the triangulation, the old vertex is overwritten.</p>
<p>Returns a handle to the new vertex. Use this handle with
<code>DelaunayTriangulation::vertex(..)</code> to refer to it.</p>
</div><h4 id='method.insert_with_hint' class="method"><span id='insert_with_hint.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.insert_with_hint' class='fnname'>insert_with_hint</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;t: V, <br>&nbsp;&nbsp;&nbsp;&nbsp;hint: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a><br>) -&gt; <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#432-434' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Inserts a new vertex into the triangulation.</p>
<p>A hint can be given to speed up the process. The hint should be a handle of a vertex
close to the new vertex. This method is recommended in combination with
<code>DelaunayWalkLocate</code>, in this case the insertion time can be reduced
to O(1) on average if the hint is close. If the hint is randomized, running time will be O(sqrt(n))
on average with an O(n) worst case.</p>
</div><h4 id='method.locate_and_remove' class="method"><span id='locate_and_remove.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.locate_and_remove' class='fnname'>locate_and_remove</a>(&amp;mut self, point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#445-451' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Attempts to remove a vertex from the triangulation.</p>
<p>Returns the removed vertex data if it could be found.</p>
<h1 id="handle-invalidation" class="section-header"><a href="#handle-invalidation">Handle invalidation</a></h1>
<p>This method will invalidate all vertex, edge and face handles
upon successful removal.</p>
</div><h4 id='method.remove' class="method"><span id='remove.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.remove' class='fnname'>remove</a>(&amp;mut self, vertex: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a>) -&gt; V</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#461-463' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Removes a vertex from the triangulation.</p>
<p>This operation runs in O(n²), where n is the degree of the
removed vertex.</p>
<h1 id="handle-invalidation-1" class="section-header"><a href="#handle-invalidation-1">Handle invalidation</a></h1>
<p>This method will invalidate all vertex, edge and face handles.</p>
</div></div><h3 id='impl-2' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;V, K&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, <a class="type" href="../../spade/delaunay/type.DelaunayTreeLocate.html" title="type spade::delaunay::DelaunayTreeLocate">DelaunayTreeLocate</a>&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../spade/trait.HasPosition2D.html" title="trait spade::HasPosition2D">HasPosition2D</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../../spade/kernels/trait.DelaunayKernel.html" title="trait spade::kernels::DelaunayKernel">DelaunayKernel</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>: <a class="trait" href="../../spade/trait.TwoDimensional.html" title="trait spade::TwoDimensional">TwoDimensional</a>,&nbsp;</span></code><a href='#impl-2' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#466-491' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.lookup' class="method"><span id='lookup.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.lookup' class='fnname'>lookup</a>(&amp;self, point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../spade/delaunay/struct.VertexHandle.html" title="struct spade::delaunay::VertexHandle">VertexHandle</a>&lt;V&gt;&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#473-476' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.3.0<p>: Use locate_vertex instead</p>
</div></div><div class='docblock'><p>Checks if the triangulation contains an object with a given coordinate.</p>
</div><h4 id='method.lookup_and_remove' class="method"><span id='lookup_and_remove.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.lookup_and_remove' class='fnname'>lookup_and_remove</a>(&amp;mut self, point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#487-490' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.3<p>: Use locate_and_remove instead</p>
</div></div><div class='docblock'><p>Removes a vertex at a given position from the triangulation.</p>
<p>This operation runs in O(n²), where n is the degree of the
removed vertex.</p>
<h1 id="handle-invalidation-2" class="section-header"><a href="#handle-invalidation-2">Handle invalidation</a></h1>
<p>This method will invalidate all vertex, edge and face handles upon
successful removal.</p>
</div></div><h3 id='impl-3' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;V, K, L&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, L&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../spade/trait.HasPosition2D.html" title="trait spade::HasPosition2D">HasPosition2D</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>: <a class="trait" href="../../spade/trait.SpadeFloat.html" title="trait spade::SpadeFloat">SpadeFloat</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../../spade/kernels/trait.DelaunayKernel.html" title="trait spade::kernels::DelaunayKernel">DelaunayKernel</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;L: <a class="trait" href="../../spade/delaunay/trait.DelaunayLocateStructure.html" title="trait spade::delaunay::DelaunayLocateStructure">DelaunayLocateStructure</a>&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>: <a class="trait" href="../../spade/trait.TwoDimensional.html" title="trait spade::TwoDimensional">TwoDimensional</a>,&nbsp;</span></code><a href='#impl-3' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#495-1028' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.barycentric_interpolation' class="method"><span id='barycentric_interpolation.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.barycentric_interpolation' class='fnname'>barycentric_interpolation</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V) -&gt; &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#506-540' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs a barycentric interpolation.
Returns <code>None</code> if the triangulation has no triangles yet.
Points outside of the convex hull will be interpolated as well.
The other interpolation methods are used very similarly, check their
documentation for an example.</p>
</div><h4 id='method.nn_interpolation' class="method"><span id='nn_interpolation.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.nn_interpolation' class='fnname'>nn_interpolation</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V) -&gt; &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#584-600' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs a natural neighbor interpolation for a given position.</p>
<p>Returns <code>None</code> if the triangulation has no triangles yet.
Points outside of the convex hull will be interpolated as well.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<pre class="rust rust-example-rendered">

<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">HasPosition</span>;
<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">delaunay</span>::{<span class="ident">FloatDelaunayTriangulation</span>};

<span class="kw">struct</span> <span class="ident">PointWithHeight</span> {
  <span class="ident">point</span>: <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>,
  <span class="ident">height</span>: <span class="ident">f64</span>,
}

<span class="kw">impl</span> <span class="ident">HasPosition</span> <span class="kw">for</span> <span class="ident">PointWithHeight</span> {
  <span class="kw">type</span> <span class="ident">Point</span> <span class="op">=</span> <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">position</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span> {
      <span class="self">self</span>.<span class="ident">point</span>
    }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">delaunay</span> <span class="op">=</span> <span class="ident">FloatDelaunayTriangulation</span>::<span class="ident">with_walk_locate</span>();
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">PointWithHeight</span> { <span class="ident">point</span>: <span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.0</span>, <span class="number">0.0</span>), <span class="ident">height</span>: <span class="number">5.</span> });
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">PointWithHeight</span> { <span class="ident">point</span>: <span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">1.0</span>, <span class="number">0.0</span>), <span class="ident">height</span>: <span class="number">0.</span> });
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">PointWithHeight</span> { <span class="ident">point</span>: <span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.0</span>, <span class="number">1.0</span>), <span class="ident">height</span>: <span class="number">0.</span> });
  <span class="kw">let</span> <span class="ident">lookup</span> <span class="op">=</span> <span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.2</span>, <span class="number">0.2</span>);
  <span class="comment">// Interpolate the points height</span>
  <span class="kw">let</span> <span class="ident">interpolated</span> <span class="op">=</span> <span class="ident">delaunay</span>.<span class="ident">nn_interpolation</span>(<span class="kw-2">&amp;</span><span class="ident">lookup</span>, <span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="ident">p</span>.<span class="ident">height</span>).<span class="ident">unwrap</span>();
  <span class="comment">// and insert it afterwards.</span>
  <span class="ident">delaunay</span>.<span class="ident">insert</span>(<span class="ident">PointWithHeight</span> { <span class="ident">point</span>: <span class="ident">lookup</span>, <span class="ident">height</span>: <span class="ident">interpolated</span> });
  <span class="comment">// Data points themselves will always yield their own height</span>
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">delaunay</span>.<span class="ident">nn_interpolation</span>(<span class="kw-2">&amp;</span><span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.0</span>, <span class="number">0.0</span>), <span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="ident">p</span>.<span class="ident">height</span>),
             <span class="prelude-val">Some</span>(<span class="number">5.0</span>));
}</pre>
</div><h4 id='method.estimate_normal' class="method"><span id='estimate_normal.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.estimate_normal' class='fnname'>estimate_normal</a>&lt;F, RV&gt;(&amp;self, v: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a>, f: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>F) -&gt; RV <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V) -&gt; &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;RV: <a class="trait" href="../../spade/trait.ThreeDimensional.html" title="trait spade::ThreeDimensional">ThreeDimensional</a>&lt;Scalar = &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#772-809' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Estimates a normal value for a given vertex.</p>
<p>This assumes that the triangulation models some kind of height field, given by the
function <code>f</code>.
The normal is the weighted and normalized average of the normals of all triangles
adjacent to the given vertex.</p>
</div><h4 id='method.estimate_gradient' class="method"><span id='estimate_gradient.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.estimate_gradient' class='fnname'>estimate_gradient</a>&lt;F&gt;(&amp;self, v: <a class="type" href="../../spade/delaunay/type.FixedVertexHandle.html" title="type spade::delaunay::FixedVertexHandle">FixedVertexHandle</a>, f: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>F) -&gt; V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V) -&gt; &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#812-829' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Estimates and returns the gradient for a single vertex in this triangulation.</p>
</div><h4 id='method.nn_interpolation_c1_sibson' class="method"><span id='nn_interpolation_c1_sibson.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.nn_interpolation_c1_sibson' class='fnname'>nn_interpolation_c1_sibson</a>&lt;F, G&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;flatness: &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F, <br>&nbsp;&nbsp;&nbsp;&nbsp;g: G<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V) -&gt; &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self, &amp;<a class="struct" href="../../spade/delaunay/struct.VertexHandle.html" title="struct spade::delaunay::VertexHandle">VertexHandle</a>&lt;V&gt;) -&gt; V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#895-935' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Interpolates a data point on this triangulation according to Sibson's c1 interpolant.</p>
<p>The interpolation given by <code>nn_interpolation</code> is not differentiable at the triangulation's
data points. Sibson introduced another interpolation scheme that takes the gradient of each
data point into account and offers an interpolation that is differentiable (c1) at the data
points.
The interpolation needs to know the gradients of the points natural neighbors, though.
Spade can estimate them automatically, see <code>estimate_gradient</code> and <code>estimate_gradients</code>.
The value that should be interpolated is given by <code>f</code>, the gradient of a vertex must
be given by <code>g</code>.</p>
<h1 id="flatness" class="section-header"><a href="#flatness">flatness</a></h1>
<p>An additional flatness factor determines how flat the triangulation will be around
the datapoints. A flatness factor of 0.5 is the factor used in sibson's original interpolant.
A flatness of 0.0 or lower is nearly identical to sibson's original interpolant
(<code>nn_interpolation(..)</code>). A factor of (exactly) 1.0 should yield best performance since
an exponentiation can be omitted.</p>
<h1 id="example-3" class="section-header"><a href="#example-3">Example</a></h1>
<pre class="rust rust-example-rendered">
 
<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">delaunay</span>::<span class="ident">FloatDelaunayTriangulation</span>;
<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">HasPosition</span>;

<span class="kw">struct</span> <span class="ident">PointWithHeight</span> {
  <span class="ident">point</span>: <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>,
  <span class="ident">gradient</span>: <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>,
  <span class="ident">height</span>: <span class="ident">f64</span>,
}

<span class="kw">impl</span> <span class="ident">HasPosition</span> <span class="kw">for</span> <span class="ident">PointWithHeight</span> {
  <span class="kw">type</span> <span class="ident">Point</span> <span class="op">=</span> <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">position</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span> {
      <span class="self">self</span>.<span class="ident">point</span>
    }
}

<span class="kw">impl</span> <span class="ident">PointWithHeight</span> {
  <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">point</span>: <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>, <span class="ident">height</span>: <span class="ident">f64</span>) <span class="op">-&gt;</span> <span class="ident">PointWithHeight</span> {
    <span class="comment">// Initialize the gradient to any value since it will be overwritten</span>
    <span class="ident">PointWithHeight</span> { <span class="ident">point</span>: <span class="ident">point</span>, <span class="ident">height</span>: <span class="ident">height</span>, <span class="ident">gradient</span>: <span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.</span>, <span class="number">0.</span>) }
  }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">delaunay</span> <span class="op">=</span> <span class="ident">FloatDelaunayTriangulation</span>::<span class="ident">with_walk_locate</span>();
  <span class="comment">// Insert some points here... (skipped)</span>
  <span class="comment">// Estimate all gradients and store them:</span>
  <span class="ident">delaunay</span>.<span class="ident">estimate_gradients</span>(<span class="kw-2">&amp;</span>(<span class="op">|</span><span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="ident">PointWithHeight</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">height</span>),
                              <span class="kw-2">&amp;</span>(<span class="op">|</span><span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">PointWithHeight</span>, <span class="ident">g</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">gradient</span> <span class="op">=</span> <span class="ident">g</span>));
   
  <span class="comment">// Now we can use the gradients for interpolation, flatness is set to 2.0:</span>
  <span class="kw">let</span> <span class="ident">interpolated</span> <span class="op">=</span> <span class="ident">delaunay</span>.<span class="ident">nn_interpolation_c1_sibson</span>(
     <span class="kw-2">&amp;</span><span class="ident">Point2</span>::<span class="ident">new</span>(<span class="number">0.5</span>, <span class="number">0.2</span>), <span class="number">2.0</span>, <span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">height</span>, <span class="op">|</span><span class="kw">_</span>, <span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">gradient</span>);
  <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;interpolated: {}&quot;</span>, <span class="ident">interpolated</span>.<span class="ident">unwrap</span>());
}</pre>
</div><h4 id='method.nn_interpolation_c1_farin' class="method"><span id='nn_interpolation_c1_farin.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.nn_interpolation_c1_farin' class='fnname'>nn_interpolation_c1_farin</a>&lt;F, G&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;point: &amp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F, <br>&nbsp;&nbsp;&nbsp;&nbsp;g: G<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V) -&gt; &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self, &amp;<a class="struct" href="../../spade/delaunay/struct.VertexHandle.html" title="struct spade::delaunay::VertexHandle">VertexHandle</a>&lt;V&gt;) -&gt; V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#942-1027' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Interpolates a data point on this triangulation using Farin's c1 interpolant.</p>
<p>This method is used in the same way as <code>nn_interpolation_c1_sibson</code>. The resulting
interpolant is very similar to sibson's c1 interpolant but uses a different algorithm.</p>
</div></div><h3 id='impl-4' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;V, K, L&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, L&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../spade/trait.HasPosition2D.html" title="trait spade::HasPosition2D">HasPosition2D</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>: <a class="trait" href="../../spade/trait.SpadeFloat.html" title="trait spade::SpadeFloat">SpadeFloat</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../../spade/kernels/trait.DelaunayKernel.html" title="trait spade::kernels::DelaunayKernel">DelaunayKernel</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;L: <a class="trait" href="../../spade/delaunay/trait.DelaunayLocateStructure.html" title="trait spade::delaunay::DelaunayLocateStructure">DelaunayLocateStructure</a>&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>: <a class="trait" href="../../spade/trait.TwoDimensional.html" title="trait spade::TwoDimensional">TwoDimensional</a>,&nbsp;</span></code><a href='#impl-4' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#1030-1105' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.estimate_normals' class="method"><span id='estimate_normals.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.estimate_normals' class='fnname'>estimate_normals</a>&lt;F, G, RV&gt;(&amp;mut self, f: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>F, g: G) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V) -&gt; &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>V, RV),<br>&nbsp;&nbsp;&nbsp;&nbsp;RV: <a class="trait" href="../../spade/trait.ThreeDimensional.html" title="trait spade::ThreeDimensional">ThreeDimensional</a>&lt;Scalar = &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#1081-1089' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Estimates a normal for each vertex in the triangulation.</p>
<p><code>f</code> must yield a 'height' value for each vertex,
<code>g</code> is a callback function that can be used to store the calculated normals.</p>

<pre class="rust rust-example-rendered">
 
<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">delaunay</span>::<span class="ident">FloatDelaunayTriangulation</span>;
<span class="kw">use</span> <span class="ident">spade</span>::<span class="ident">HasPosition</span>;

<span class="kw">struct</span> <span class="ident">PointWithHeight</span> {
  <span class="ident">point</span>: <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>,
  <span class="ident">normal</span>: <span class="ident">Point3</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>,
  <span class="ident">height</span>: <span class="ident">f64</span>,
}

<span class="kw">impl</span> <span class="ident">HasPosition</span> <span class="kw">for</span> <span class="ident">PointWithHeight</span> {
  <span class="kw">type</span> <span class="ident">Point</span> <span class="op">=</span> <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;
    <span class="kw">fn</span> <span class="ident">position</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span> {
      <span class="self">self</span>.<span class="ident">point</span>
    }
}
<span class="kw">impl</span> <span class="ident">PointWithHeight</span> {
  <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">point</span>: <span class="ident">Point2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>, <span class="ident">height</span>: <span class="ident">f64</span>) <span class="op">-&gt;</span> <span class="ident">PointWithHeight</span> {
    <span class="ident">PointWithHeight</span> { <span class="ident">point</span>: <span class="ident">point</span>, <span class="ident">height</span>: <span class="ident">height</span>, <span class="ident">normal</span>: <span class="ident">Point3</span>::<span class="ident">new</span>(<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>) }
  }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">delaunay</span> <span class="op">=</span> <span class="ident">FloatDelaunayTriangulation</span>::<span class="ident">with_walk_locate</span>();
  <span class="comment">// Insert some points here... (skipped)</span>
  <span class="comment">// Then, estimate all normals at once:</span>
  <span class="ident">delaunay</span>.<span class="ident">estimate_normals</span>(<span class="kw-2">&amp;</span>(<span class="op">|</span><span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="ident">PointWithHeight</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">height</span>), <span class="kw-2">&amp;</span>(<span class="op">|</span><span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">PointWithHeight</span>, <span class="ident">n</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">normal</span> <span class="op">=</span> <span class="ident">n</span>));
   
  <span class="comment">// And print them</span>
  <span class="kw">for</span> <span class="ident">vertex</span> <span class="kw">in</span> <span class="ident">delaunay</span>.<span class="ident">vertices</span>() {
     <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;vertex: {:?}, normal: {:?}&quot;</span>, <span class="ident">vertex</span>.<span class="ident">position</span>(), <span class="ident">vertex</span>.<span class="ident">normal</span>);
  }
}</pre>
</div><h4 id='method.estimate_gradients' class="method"><span id='estimate_gradients.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.estimate_gradients' class='fnname'>estimate_gradients</a>&lt;F, G&gt;(&amp;mut self, f: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>F, g: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>G) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>V) -&gt; &lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>V, V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>),&nbsp;</span></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#1097-1104' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Estimates gradients for all vertices in this triangulation.</p>
<p><code>f</code> yields the value for which a gradient should be calculated,
<code>g</code> can be used to store the gradient. See <code>estimate_normals</code> for a similar example.</p>
<p>Internally, the normal for each vertex is calculated first. Then, an appropriate
gradient is calculated.</p>
</div></div>
                <h2 id='implementations' class='small-section-header'>
                  Trait Implementations<a href='#implementations' class='anchor'></a>
                </h2>
                <div id='implementations-list'><h3 id='impl-Clone' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;V, K, L&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, L&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../spade/trait.HasPosition2D.html" title="trait spade::HasPosition2D">HasPosition2D</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../../spade/kernels/trait.DelaunayKernel.html" title="trait spade::kernels::DelaunayKernel">DelaunayKernel</a>&lt;&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a> as <a class="trait" href="../../spade/trait.PointN.html" title="trait spade::PointN">PointN</a>&gt;::<a class="type" href="../../spade/trait.PointN.html#associatedtype.Scalar" title="type spade::PointN::Scalar">Scalar</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>: <a class="trait" href="../../spade/trait.TwoDimensional.html" title="trait spade::TwoDimensional">TwoDimensional</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;L: <a class="trait" href="../../spade/delaunay/trait.DelaunayLocateStructure.html" title="trait spade::delaunay::DelaunayLocateStructure">DelaunayLocateStructure</a>&lt;V::<a class="type" href="../../spade/trait.HasPosition.html#associatedtype.Point" title="type spade::HasPosition::Point">Point</a>&gt;,&nbsp;</span></code><a href='#impl-Clone' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#190-204' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.clone' class="method"><span id='clone.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, L&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/spade/delaunay/delaunay2d.rs.html#196-203' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method"><span id='clone_from.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code></span></td><td><span class='out-of-band'><div class='ghost'></div><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/clone.rs.html#130-132' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div></div>
                <h2 id='synthetic-implementations' class='small-section-header'>
                  Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a>
                </h2>
                <div id='synthetic-implementations-list'>
            <h3 id='impl-Send' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;V, K, L&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, L&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;L: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></code><a href='#impl-Send' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl&lt;V, K, L&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../spade/delaunay/struct.DelaunayTriangulation.html" title="struct spade::delaunay::DelaunayTriangulation">DelaunayTriangulation</a>&lt;V, K, L&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;L: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></code><a href='#impl-Sync' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "spade";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>